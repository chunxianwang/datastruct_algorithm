# 算法与数据结构笔记-week7:字典树（前缀树）、并查集、AVL树、红黑树

### trie 字典树

Trie 又称为单词查找树，是一种树形结构，但是和树又有所不同。典型应用是快速统计和排序大量字符串，被搜索引擎用于词频统计。
给出一组单词，inn, int, at, age, adv, ant，可以形成如下的Trie：
![](https://gitee.com/chunxianwang/ImageHost/raw/master/uPic/Wi28RN.jpg)

优点：最大限度减少无谓的字符串比较，查询效率比哈希表高。

结构特点：
1. 结点本身不存完整单词；
2. 单词字符存储在结点到子结点间的路径（指针）上；
3. 从根节点到某一结点，路径上经过的字符串连接起来，就是该结点对应的字符串（对应于一般意义上的单词或词缀）；

[LeetCode：Trie算法讲解，含例题](https://leetcode-cn.com/circle/article/mv8GnX/)

----
### 数组指针 vs 指针数组
* 数组指针*：int* a[10] 是包含10个int指针的数组
  先找到声明符a,然后向右看，有[ ]说明a是个数组，再向左看，是int *，说明数组中的每个元素是int *。所以这是一个存放int指针的数组。

* 指针数组*：int(*a)[10] 是包含10个int元素的数组的指针
  先找到声明符a,被括号括着，先看括号内的(优先级高)，然后向右看，没有，向左看,是*，说明a是个指针，什么指针？再看括号外面的，先向右看，有[ ] 是个数组，说明a是个指向数组的指针，再向左看，是int，说明数组的每个元素是int。所以，这是一个指向存放int的数组的指针。 

例如在tri中：
class Trie {
private:
    bool isEnd;
    Trie* next[26]; //数组指针，包含26个Trie*指针的数组
public:
    //方法...
};

----
### 并查集
常用的问题场景是：考虑集合元素间的内部关系后，集合的分布情况，如其中有几个独立的子集？

**核心思想**
每个结点有两个属性：自身编号x，及其父结点的编号parent[x]

先假设各个结点独立，父结点指向自己，parent[x] = x；

再遍历结点间的关系信息，遍历过程做两个事情：
两个结点有关联，（属于同一个集合）
1. 查找，查找其父结点，查找父结点的父结点，知道找到所属集合的领头结点；
2. 合并，对两个结点合并
   如果其领头父结点相同，说明它们本属于一个结合，不做合并动作；
   如果其领头父结点不同，说明它们原不属一个结合，则进行合并（把其中一个结点的父结点，指向另外一个结点即可）


### 模板 && 模板题目
* **双向BFS** 
127 [单词搜索](212.单词搜索-ii.cpp)
433 [最小基因](433.最小基因变化.cpp)

----
## AVL树和红黑树

**回顾二叉搜索树**
* 定义
  左子树上所有结点的值均小于它的根结点的值；
  右子树上所有结点的值均大于它的根结点的值；
  依此类推，左右子树也分别是二叉搜索树
* 特点，中序遍历，是升序

* 在左右子树结点平衡时，查找的操作数，等于树的高度；即logN， N是所有结点数

==>**平衡二叉搜索树**
多种实现方式，这里介绍AVL和红黑树

#### AVL树 （严格平衡）
1. balance factor 平衡因子
   每个结点的平衡因子 = 左子树高度 - 右子树高度
   AVL树的平衡因子，保证处于{-1, 0, 1}的范围
2. 旋转操作实现平衡
   当平衡因子大于1或小于-1时，通过四种旋转操作，实现平衡
   * 左旋-->右右子树
   * 右旋-->左左子树
   * 左右旋-->左右子树
   * 右左旋-->右左子树
3. 缺点
   * 每次插入和删除操作，都要重新计算平衡因子，以及可能要进行旋转操作来重新平衡
   * 每个结点要存int型的平衡因子，占用数据存储空间大


对平衡因子，适当妥协，平衡因子是2、4...在一定程度上能减小插入、删除的平衡操作
#### 红黑树（近似平衡，降低插入、删除操作数）
红黑树是一种近似平衡的二叉搜索树（Binary Search Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：
• 每个结点要么是红色，要么是黑色
• 根节点是黑色
• 每个叶节点（NIL节点，空节点）是黑色的。
• 不能有相邻接的两个红色节点
• 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

* 关键性质
  从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。

### 搜索
#### BFS搜索
在起点开始，向外一层层扩散；
队列缓存：遍历当前层时，向队列中缓存下一层节点信息；
直到队列为空之前找到搜索目标，或者队列为空，退出搜索循环。
```c++
//BFS模板
//定义bfs节点容器
struct Node {
  int x;
  Node(int i) : x(i){}
};
//队列存放起始节点
queue<Node> q;
Node startnode(x0);
q.push(startnode);
//队列不为空就继续search
while (!q.empty()) {
  Node curnode = q.front();
  q.pop();
  #判断curnode 是否是 target node ?
  //创建下一节点，放入队列
  Node nextnode;
  q.push(nexnode);
}
```
#### 启发式搜索 A* search
BFS是无差别遍历所有节点，有些节点明显偏离目标节点，也会被无差别访问，就造成了时间浪费。
启发式搜索，在BFS基础上加入“启发操作”，优先遍历距离目标节点近的节点，忽略掉明显偏离目标的节点。
利用优先队列priority_queue实现上述"优先遍历"操作：队列中每次加入新节点，都会根据一定的原则进行优先排序；在队列中取节点时，是取队列最上端的优先级最高节点。

关键是实现优先策略，实题目可参考[](1091.二进制矩阵中的最短路径.cpp)

```c++
//A* 模板
//定义bfs节点容器
struct Node {
  int x;
  Node(int i) : x(i){}
};
int heuristic(const Node A) {
  #function with A//定义优先级估值函数
}
//重载运算符，自定义优先级判定方法
bool operator < (const Node A, const Node B) {
  return heuristic(A) > heuristic(B);//小顶队列
  //return heuristic(A) < heuristic(B);//大顶队列
}

//队列存放起始节点
priority_queue<Node> pq;
Node startnode(x0);
pq.push(startnode);
//队列不为空就继续search
while (!pq.empty()) {
  Node curnode = pq.front();
  pq.pop();
  #判断curnode 是否是 target node ?
  //创建下一节点，放入队列
  Node nextnode;
  pq.push(nexnode);
}
```