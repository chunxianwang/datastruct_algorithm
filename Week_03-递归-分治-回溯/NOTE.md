# 算法与数据结构笔记-week3:递归、分治、回溯
### 递归
白话递归：当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的，也可以理解为自我复制的效果。
非常可惜，这是一个无穷递归，a bad case！
在算法中，我们说的递归概念，是有终止条件的递归。
因为我们选用某个算法的期望就是，利用较小的时间复杂度解决(终止)问题。
#### 什么样的场景适合用递归？
1. 一个问题的解可以分解为几个子问题的解。
2. 这个问题和分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归的终止条件。

**递归的4个标准流程**
1. 判断递归终止条件
2. 处理当前层逻辑
3. 下探到下一层
4. 清理当前层的状态（如果需要的话）

树结构和递归，是“神仙眷侣”，如果问题可抽象成树结构，那么一定要想着如何使用递归解决问题。

利用二叉树遍历/生长过程，描述递归的4个标准流程
1. 递归终止条件：二叉树是否长足或遍历到“终点”根
2. 处理当前层逻辑：当前层长出子树或访问当前层根节点
3. 下探到下一层：进入下一层子树
4. 清理当前层状态（如果需要的话）

下探到下一层时，要带入两部分内容：待下一层处理的数据（必须），当前层经过逻辑处理更新的状态（非必须）。

#### 递归题目的三个思维要点
* 不要人肉进行递归
* 找到最近重复子问题
* 数学归纳思维

**泛型递归的代码模版**
```c++
void recursion(level, param1, param2, ...) {
  //终止条件
  if (level > MAX_LEVEL) {
    process_result();
    return;
  }

  //处理当前层逻辑
  process(level, data, ...)

  //进入下一层
  recursion(level+1, p1, p2, ...)

  //恢复当前层状态（如果需要）
}
```
#### 分治和回溯
分治和回溯本质上是递归，可认为是递归的一个细分类

**分治**就是把一个问题分解为多个子问题，本质上就是找到问题的重复性，最后把子问题的解组合，得到总问题的解。（最后组合过程是分治的特点）

**分治代码模板** 
```c++
subreuslt divide_conquer(problem, param1, param2, ...) {
  //终止条件，没有子问题需要解决
  if problem is None
  print_result();
  return;

  //拆解子问题
  data = prepare_data(problem);
  subproblems = split_problem(problem, data)

  //治理子问题，drill down到下一层
  subresult1 = divide_conquer(subproblems[0], p1, ...);
  subresult2 = divide_conquer(subproblems[1], p1, ...);
  ...

  //把子问题的解组装，得到最终解
  result = process_result(subresult1, subresult2, ...);
  
  //恢复当前层状态（如果需要）
}
```

分治 -》本质就是递归再加上最后要把子问题组合得到最终结果

回溯 -》不断地在每一层去试，如果不行就及时回来。如[22括号生成问题](22.括号生成.cpp)和[8皇后问题]

深拷贝 浅拷贝

#### 收藏
[如何理解动态规划](https://zhuanlan.zhihu.com/p/91582909)
[如何理解递归](https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ)



