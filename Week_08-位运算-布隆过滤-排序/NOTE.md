# 算法与数据结构笔记-week8:位运算、布隆过滤器、LRU Cache、排序


## c++重载操作符(operator)
### 1.what?
operator 是C++的关键字，它和运算符（如=）一起使用，表示一个**运算符重载函数**，在理解时可将operator和运算符（如operator=）视为一个函数名。

使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下：

### 2.why?
**面向用户自己定义的类**
对于C++提供的所有操作符，通常只支持对于基本数据类型和标准库中提供的类的操作;
而对于**用户自己定义的类**，如果想要通过该操作符实现一些基本操作（比如比较大小，判断是否相等），就需要用户自己来定义关于这个操作符的具体实现了。

比如，我们要设计一个名为“person”的类，现在要判断person类的两个对象p1和p2是否一样大，我们设计的比较规则是按照其年龄来比较，那么，在设计person类的时候，就可以通过对操作符“==”进行重载，来使用操作符“==”对对象p1和p2进行比较了（实际上比较的内容应该是person类中的数据成员“age”）。

我们上面说的对操作符“==”进行重载，说是“重载”，是由于编译器在实现操作符“==”功能的时候，已经为我们提供了这个操作符对于一些基本数据类型的操作支持，只不过由于现在该操作符所操作的内容变成了我们自定义的数据类型（如class），而默认情况下，该操作符是不能对我们自定义的class类型进行操作的，所以，就需要我们通过重载该操作符，给出该操作符操作我们自定义的class类型的方法，从而达到使用该操作符对我们自定义的class类型进行运算的目的。

### 3.how？
**格式** 
```c++
type operator>(const class& obj1, const class& obj2) {
    this->value...
    obj1.value...
    obj2.balue...
}
```
**位置**
实现一个操作符重载的方式通常分为两种情况：
* 将操作符重载实现为类的成员函数；
* 操作符重载实现为非类的成员函数（即全局函数）。
**示例**
```c++
#include <iostream>
using namespace std;
class person {
private:
    int age;
public:
    person(int nAge){
        this->age = nAge;
    }
    bool operator==(const person& ps){
        if (this->age == ps.age){
            return true;
        }
        return false;
    }
};

int main()
{
    person p1(10);
    person p2(10);
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is not equal with p2." << endl;
    return 0;
}
```

```c++
#include <iostream>
using namespace std;
class person {
public:
    int age;
};
// 左操作数的类型必须被显式指定
// 此处指定的类型为person类
bool operator==(person const& p1 ,person const& p2) {
    if (p1.age == p2.age) return true;
    else return false;
}
int main()
{
    person p1;
    person p2;
    p1.age = 18;
    p2.age = 18;
    if (p1 == p2) cout << "p1 is equal with p2." << endl;
    else cout << "p1 is NOT equal with p2." << endl;
    return 0;
}
```
#### 操作符重载的方式选择
可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数：
如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数；
C++要求'='、'[]'、'()'、'->'操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误
如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。
#### 操作符重载的限制
实现操作符重载时，需要注意：
重载后操作符的操作数至少有一个是用户定义类型；
不能违反原来操作数的语法规则；
不能创建新的操作符；
不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符
=、()、[]、以及 ->操作符只能被类的成员函数重载
#### 优先队列：用重载操作符<，自定义优先级
```c++
//自定义地按照队列的value值大小排序。<表示，B在A前面；B的value较小，因此value小的节点排在优先队列的顶部，即实现了一个小顶堆
//这里value可自定义为其它待比较数值；
priority_queue<Node> pq;
bool operator < (const Node A, const Node B) {
    return A.value > B.value; //小顶堆
    //return A.value < B.value;  //大顶堆  
}
```

----
## 位运算
* 奇偶判断
x%2 == 1  ==>  (x&1)==1  //奇数
x%2 == 0  ==>  (x&1)==0  //偶数

* 除以二
  x/2     ==>  x>>1

* 清零最低位的1
  x = x&(x-1)

* 得到最低位的1
  x&(-x)
* 得到0
  x&(~x) 

----
## 布隆过滤器
[原理和实现参考文章](https://www.cnblogs.com/cpselvis/p/6265825.html)

#### 什么时候使用？
布隆过滤器，一般用于快速查找某个元素是否在集合中。
* 字处理软件中，快速查询英语单词是否拼写正确？（输入单词是否在英语单词词典中）。
* 在网络爬虫里，一个网站是否访问过？
* yahoo 和 gmail等邮箱，垃圾邮件过滤功能。检查当前邮件是否在垃圾邮件集合中。

常常作为数据库的最外层，快速判断某个元素是否在数据库中，如果反馈不在其中，那就肯定不在其中了；如果反馈在其中，那就是可能在其中，也可能不在，需要进入数据库做更多查询操作。

#### 实现原理
核心实现包括两部分：
位数组，存放很多0和1元素的数组；
哈希函数（组），把待查询元素输入到哈希函数（组），得到对应的位数组中的某些位数据。  //本质上是多个哈希函数组成，每个哈希函数得到一个位数据。

判断原则：如果这些位数据都是1，那么这个待查询元素可能存在，准确的判断，需要进一步的查询；如果这些位数据中有0，那么这个待查询元素一定不存在。

举例：
对某个元素，通过3个哈希函数映射得到对应的位数组（比如对应位素组中的3位），如果这3位都是1，那么此元素可能存在；如果3位不全部是1，那么此元素一定不存在。

**布隆过滤器元素添加**
* 将要添加的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 将这k个位置设为1

**布隆过滤器查询元素**
* 将要查询的元素给k个哈希函数
* 得到对应于位数组上的k个位置
* 如果k个位置有一个为0，则肯定不在集合中
* 如果k个位置全部为1，则可能在集合中

**对比哈希表**，布隆过滤器占用空间小，查询速度更快，尤其是快速得到某元素不在集合中。

----
## LRU Cache (least recently used cache)
参考[LRU Cache](https://www.jianshu.com/p/379b5e0624d4)
### 什么是Cache-Cache概念
Cache，即高速缓存，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。
当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。
如果存在（命中），则直接返回该数据
如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器
提供“高速缓存”的目的是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。

### Cache原理
Cache 技术所依赖的原理是”程序执行与数据访问的局部性原理“，这种局部性表现在两个方面：
**时间局部性**：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。
**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。
时间局部性是通过将近来使用的指令和数据保存到Cache中实现。
空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。

### Cache替换策略
Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：
1. 随机算法（Rand）：随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但命中率比较低。

2. 先进先出算法（FIFO, First In First Out）：先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的块，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但还不满足要求。

3. 最久未使用算法（LRU, Least Recently Used）：LRU法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。

4. 最不经常使用算法（LFU, Least Frequently Used）：将最近一段时期内，访问次数最少的块替换出Cache。

**LRU缓存操作原理**
头部放最新访问数据，尾部放很久前访问的数据；
1.访问数据，查询待访问数据地址，若有，返回此地址中存储的值，并把它放入头部；
2.存入数据，查询待访问数据地址，若有，把它调整到头部；若无，把它插入到头部，并判断cache是否溢出（超过其capacity），若溢出，删掉尾部；

LRU的get，put操作的两个关键元素：key 和 value， 理解成cache的地址索引和其中存储的值；
note，为区别哈希列表和cache，在下述哈希列表中，用键和值表述hash_map的key和value；
双向链表，cache的数据存储。 key，对应于cache的key，就是cache的地址索引；value，对应于cache的value，实际存放的数据；
哈希列表，键，对应于cache的key，就是cache的地址索引； 值，对应于链表的结点的地址；

**为什么不用单链表**
单向链表，只定义了head，如果想要快速访问tail，要逐个从头部到尾部遍历，时间复杂度O(n)；不适用于用O(1)访问和删除尾部的场景；
而双向链表，定义了head和tail，访问和删除尾部时，就比较迅速了;

通俗说就是，单链表能实现新来的放头部，最久不用的在尾部删除。但删除尾部元素的时候需要遍历到尾部，因为单链表只有头指针。在用到已经用到过的数据时，还要遍历整合链表，来确定是否用过，然后再遍历到响应位置来剔除的节点，并重新放在头部。这效率可想而知。



----
## 排序
![各类排序算法比较](https://gitee.com/chunxianwang/ImageHost/raw/master/uPic/VRnCjZ.jpg)
一般排序时间复杂度是O(N^2),重点学习三种O(NlogN)的排序方法；
* 快速排序
* 归并排序
* 堆排序

### 快速排序
分治思想：局部问题解决，合起来就把整体问题解决了。
练习题目:[912.排序数组](912.排序数组.cpp)
**快速排序思想**
1. 在序列中随机找一个数作为标杆；
2. 遍历序列，小于标杆的放在左侧，大于标杆的放在右侧；效果是为标杆找到了排序序列中的合适位置。
3. 在标杆左、右两侧子序列中，分别重复过程1、2。
4. 直到处理完所有最小粒度（2或3个元素）的子序列。

**具体操作实现**
[参考文章-快速排序法（详解）](https://blog.csdn.net/qq_40941722/article/details/94396010?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

**优化原理**
快速排序之所以比较快，是因为与冒泡排序相比，每次的交换是跳跃式的；
每次排序的时候设置一个标杆，将小于等于标杆的数全部放到标杆的左边，将大于等于标杆的数全部放到标杆的右边。
这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，**交换的距离就大的多了**。
因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(n^2)，它的平均时间复杂度O(nlog2n)。

### 归并排序
快速排序核心思想：用标杆将序列一分为二，左右有序列，但左右内部无序；递归分成更小子序列；
**归并排序恰巧与快排思想相反**：
序列一分为二，且通过递归分成很小子序列，先对两个小的子序列内部排序，再把两个子序列合并；

### 堆排序
利用大顶堆和小顶堆的特性，
c++ 中使用stl中的priority_queue来实现；
[参考stl：priority_queue用法详解](http://c.biancheng.net/view/480.html)
其中priority_queue::push(), priority_queue::pop()时间复杂度都是O(logn)的。
n个元素，那么整体时间复杂度O(nlogn)。